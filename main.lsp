;Чуйков Петр, 325 группа, 2017
;Вариант: "Преобразование алгебраических выражений"

(defun main (l)
  (let ((input (trans l nil 1))) (cons (car input) (collect (cddr input) (list (cadr input))))))

(defun trans (part res)
  (cond	((null part) res)
	((numberp (car part)) (trans (cdr part)
				     (koef_part (car part) res)))
	((eql (cadr part) (quote ^)) (trans (cdddr part)
					    (append res (list (list (car part)
								   (caddr part))))))
	(T (trans (cdr part) (append res (list (list (car part) 1)))))))

(defun koef_part (numb res)
  (cond ((null res) (cons numb res))
	((numberp (car res)) (cons (* (car res) numb)
				   (cdr res)))
	(T (cons numb res))))

(defun collect (input res)
  (cond ((null input) res)
	((collect (cdr input) (mul_similar (car input) res)))))


(defun mul_similar (add_el res)
  (cond ((null res) (append res (list add_el)))
	((eql (car add_el) (caar res)) (cons (list (car add_el)
						   (+ (cadr add_el)(cadar res)))
					     (cdr res)))
	((cons (car res) (mul_similar add_el (cdr res))))))

(defun divide_to_part (polinom part minus)
  (cond ((null polinom) (div_to_part part minus))
	((eql (car polinom) (quote -)) (append (div_to_part part minus)
					       (divide_to_part (cdr polinom) nil (quote -1))))
	((eql (car polinom) (quote +)) (append (div_to_part part minus)
					       (divide_to_part (cdr polinom) nil (quote 1))))
	(t (divide_to_part (cdr polinom) (append part (list (car polinom))) minus))))

(defun div_to_part (part minus)
 ; (print (quote part1))
 ; (print part)
  (cond ((high_level part) (manage_mul (first_bracket_end (cons minus part)) nil))
	((null part) nil)
	(t (let ((collect_1 (trans part (list minus))))
	     (list (cons (car collect_1) (collect (cdr collect_1) nil)))))))
(defun qrt (polinom)
  (cond ((null polinom) nil)
	((listp (car polinom)) (qrt2 polinom))
	(t (cons (car polinom) (qrt (cdr polinom))))))

(defun qrt2 (polinom)
  (cond ((eql (cadr polinom) (quote ^)) (cond ((eql (caddr polinom) (quote 2)) (cons (car polinom)
									       (cons (car polinom) (qrt (cdddr polinom)))))
					      (t (cons (car polinom)
						       (qrt (cons (car polinom)
								  (cons (cadr polinom)
									(cons (- (caddr polinom) (quote 1)) (cdddr polinom)))))))))
	(t (cons (car polinom) (qrt (cdr polinom))))))
	
(defun empty (res)
  (cond ((null res) (list (quote 0)))
	(t res)))

(defun d (polinom)
  (empty (retrans (external_collect (divide_to_part (qrt polinom) nil 1) nil) nil)))

(defun external_collect (input res)
  (cond ((null input) res)
	(t (external_collect (cdr input) (add_similar (car input) res)))))

(defun add_similar (new_el res)
  (cond ((null res) (append res (list new_el)))
	((compare_parts (cdr new_el) (cdar res)) (cons (cons (+ (car new_el) (caar res))
							     (cdar res))
						       (cdr res)))
	(t (cons (car res) (add_similar new_el (cdr res))))))

(defun compare_parts (new_el templ)
  (cond ((and (null new_el) (null templ)) t)
	((or (null new_el) (null templ)) nil)
	((null (cdr templ)) (and (null (cdr new_el))
				 (and (eql (caar new_el) (caar templ)) (eql (cadar new_el) (cadar templ)))))
	((let ((tail_templ (compare_one_many (car new_el) templ nil)))
	   (cond ((null tail_templ) nil)
		 (t (compare_parts (cdr new_el) tail_templ)))))))

(defun compare_one_many (car_new templ res)
  (cond ((null templ) nil)
	((and (eql (car car_new) (caar templ)) (eql (cadr car_new) (cadar templ))) (append res (cdr templ)))
	(t (compare_one_many car_new (cdr templ) (append res (list (car templ)))))))

(defun delete_spare_bracket (polinom pred_oper)
  (cond ((null polinom) nil)
	((listp (car polinom)) (d_s_b2 polinom pred_oper))
	((or (eql (car polinom) (quote +)) (eql (car polinom) (quote -))) (cons (car polinom) (delete_spare_bracket (cdr polinom) (quote +))))
	(t (cons (car polinom) (delete_spare_bracket (cdr polinom) (quote *))))))

(defun d_s_b2 (polinom pred_oper)
  ;(print (quote polinom))
  ;(print polinom)
  ;(print (quote pred_oper))
  ;(print pred_oper)
  (cond ((eql pred_oper (quote *)) (cons (delete_spare_bracket (car polinom) (quote +)) (delete_spare_bracket (cdr polinom) (quote *))))
	((null (cdr polinom)) (append (delete_spare_bracket (car polinom) (quote +)) (delete_spare_bracket (cdr polinom) (quote *))))
	((not (or (eql (cadr polinom) (quote +)) (eql (cadr polinom) (quote -))))
	 (cons (delete_spare_bracket (car polinom) (quote +)) (delete_spare_bracket (cdr polinom) (quote *))))
	((or (eql (cadr polinom) (quote +)) (eql (cadr polinom) (quote -)))
	 (append (delete_spare_bracket (car polinom) (quote +)) (delete_spare_bracket (cdr polinom) (quote *))))))

(defun mul_bracket (mul1 mul2 res)
  (cond ((null mul1) res)
	(t (mul_bracket (cdr mul1) mul2 (append res (mul_one_on_bracket (car mul1) mul2))))))

(defun mul_one_on_bracket (one bracket)
  (cond ((null bracket) nil)
	(t (cons (mul_one one (car bracket) nil) (mul_one_on_bracket one (cdr bracket))))))

(defun mul_one (one two res)
  ;(print (quote mul_one))
  ;(print (quote (append res (append one two))))
  ;(print (append res (collect (append (cdr one) (cdr two)) nil)))
  (cond ((numberp (car one)) (mul_one (cdr one) (cdr two) (list (* (car one) (car two)))))
	((null one) (cond ((null two) res)
			  (t (append res two))))
	((null two) (append res one))
	(t (append res (collect (append one two) nil)))))

(defun high_level (l)
  (cond ((null l) nil)
	((listp (car l)) t)
	(t (high_level (cdr l)))))

(defun first_bracket_end (part)
 ; (print (quote  (first_bracket_end part == )))
 ; (print part)
  (cond ((null part) nil)
	((listp (car part)) (append (first_bracket_end (cdr part)) (list (car part))))
	(t (cons (car part) (first_bracket_end (cdr part))))))

(defun manage_mul (brackets part)
   ;(print (quote  (manage_mul brackets == )))
   ;(print brackets)
   ;(print (quote  (manage_mul part == )))
   ;(print part)
  (cond ((null brackets) (list (list (quote 1))))
	((listp (car brackets)) (manage_mul_listp brackets part))
	((manage_mul (cdr brackets) (append part (list (car brackets)))))))

(defun manage_mul_listp (brackets part)
 ;(print (quote manage_mul_listp))
 ;(print (quote brackets))
 ;(print brackets)
 ;(print (quote part))
 ;(print part)
  (cond ((null part) (mul_bracket (divide_to_part (car brackets) nil (quote 1))
				   (manage_mul (cdr brackets) nil)
				   nil))
	(t (let ((collect_1 (trans part (list 1))))
	     (mul_bracket (list (cons (car collect_1) (collect (cdr collect_1) nil)))
			  (mul_bracket (divide_to_part (car brackets) nil (quote 1))
				       (manage_mul (cdr brackets) nil) nil)
			  nil)))))

(defun retrans (input res)
  ;(print (quote retrans))
  ;(print (quote input))
  ;(print input)
  ;(print (quote res))
  ;(print res)
  (cond ((null input) res)
	((eql (caar input) (quote 0)) (retrans (cdr input) res))
	(t (retrans (cdr input) (append res (retrans_part (car input) nil res))))))

(defun retrans_part (part res res_big)
  ;(print (quote retrans_part))
  ;(print (quote part))
  ;(print part)
  ;(print (quote res))
  ;(print res)
  ;(print (quote res_big))
  ;(print res_big)
  (cond ((null part) res)
	((numberp (car part)) (retrans_numb part res res_big))
	((eql (cadar part) (quote 1)) (retrans_part (cdr part) (append res (list (caar part))) res_big))
	(t (retrans_part (cdr part) (append res
					    (list (caar part) (quote ^) (cadar part)))
			 res_big))))

(defun retrans_numb (part res res_big)
  ;(print (quote retrans_numb))
  ;(print (quote part))
  ;(print part)
  ;(print (quote res))
  ;(print res)
  ;(print (quote res_big))
  ;(print res_big)
  (cond ((> (car part) 0) (retrans_numb_plus part res res_big))
	((and (= (car part) -1) (null (cdr part))) (retrans_part (cdr part) (list (quote -) 1) res_big))
	((= (car part) -1) (retrans_part (cdr part) (list (quote -)) res_big))
	(t (retrans_part (cdr part) (list (quote -) (* (car part) -1)) res_big))))

(defun retrans_numb_plus (part res res_big)
  ;(print (quote retrans_numb_plus))
  ;(print (quote part))
  ;(print part)
  ;(print (quote res))
  ;(print res)
  ;(print (quote res_big))
  ;(print res_big)
  (cond ((null res_big) (cond ((eql (car part) (quote 1)) (cond ((null (cdr part)) (retrans_part (cdr part) (list (car part)) res_big))
								(t (retrans_part (cdr part) nil res_big))))
			      (t (retrans_part (cdr part) (list (car part)) res_big))))
	((and (eql (car part) (quote 1)) (null (cdr part))) (retrans_part (cdr part) (list (quote +) 1) res_big))
	((eql (car part) (quote 1)) (retrans_part (cdr part) (list (quote +)) res_big))
	(t (retrans_part (cdr part) (list (quote +) (car part)) res_big))))




